# UUID-Based Primary Keys Design

**Date:** 2025-11-10
**Status:** Approved
**Migration Strategy:** Fresh start (no data migration)

## Overview

Replace auto-incrementing integer primary keys with UUID-based string identifiers for canisters. This design maintains the current UUID format (`GC-{uuid[:6]}{timestamp[-4:]}`) and introduces a separate editable label field for user-friendly names.

## Goals

1. Use UUID-based strings as primary keys for canisters
2. Maintain current UUID format: `GC-a3f8e52468` (10 chars after prefix)
3. Add separate editable label field for human-friendly names
4. Update all routes, templates, and APIs to use string IDs
5. Preserve existing functionality while improving uniqueness guarantees

## Database Schema Changes

### Canister Model

**Before:**
```python
class Canister(BaseModel):
    # id = IntegerField (auto-generated by Peewee)
    label = CharField()
    canister_type = ForeignKeyField(CanisterType, backref='canisters')
    status = CharField(default='active')
    created_at = DateTimeField(default=datetime.now)
```

**After:**
```python
class Canister(BaseModel):
    id = CharField(primary_key=True)  # UUID-based string
    label = CharField(max_length=64)  # User-editable friendly name
    canister_type = ForeignKeyField(CanisterType, backref='canisters')
    status = CharField(default='active')
    created_at = DateTimeField(default=datetime.now)
```

**Key changes:**
- `id`: CharField with `primary_key=True` instead of auto-increment integer
- `label`: Remains CharField but now represents user-editable friendly name (max 64 chars, cannot be empty)
- Foreign keys in `Weighing` automatically adapt to new ID type

### Other Models

**No changes required:**
- `CanisterType`: Unchanged
- `Weighing`: Foreign key reference automatically handles string IDs

### Database Recreation

- Drop and recreate all tables (fresh start)
- Seed data repopulated with new UUID-based IDs
- Existing data will be lost (acceptable for this deployment stage)

## UUID Generation

### Generation Function

Location: `routers/views.py` or new `utils.py`

```python
import uuid
from datetime import datetime

def generate_canister_id():
    """
    Generate unique canister ID using UUID + timestamp.
    Format: GC-{uuid[:6]}{timestamp[-4:]}
    Example: GC-a3f8e52468
    """
    uuid_part = uuid.uuid4().hex[:6]
    timestamp_part = str(int(datetime.now().timestamp()))[-4:]
    return f"GC-{uuid_part}{timestamp_part}"
```

**Characteristics:**
- UUID component: 6 hex characters (random)
- Timestamp component: 4 digits (last 4 of Unix timestamp)
- Prefix: `GC-` for "Gas Canister"
- Total length: 13 characters
- Collision probability: Extremely low (UUID randomness + timestamp uniqueness)

### Generation Strategy

**Application-level generation:**
- Generate ID in route handlers before `Canister.create()`
- Explicit and testable
- Easy to add logging and error handling
- ID generation happens in `POST /api/canisters` route

## API Changes

### Route Parameter Types

All routes change from `int` to `str` for canister IDs:

**Before:**
```python
@router.get("/{canister_id}", response_model=CanisterResponse)
def get_canister(canister_id: int):
    ...
```

**After:**
```python
@router.get("/{canister_id}", response_model=CanisterResponse)
def get_canister(canister_id: str):
    ...
```

### Affected Routes

- `POST /api/canisters` - Generate UUID in handler
- `GET /api/canisters/{canister_id}` - Accept string ID
- `PATCH /api/canisters/{canister_id}/status` - Accept string ID
- `POST /canister/{canister_id}/delete` - Accept string ID
- `POST /weighing/{weighing_id}/delete` - No change (weighing IDs remain integers)

### Request/Response Schemas

```python
class CanisterCreate(BaseModel):
    label: str  # User-friendly name (1-64 chars, required)
    canister_type_id: int
    # No id field - generated by server

class CanisterResponse(BaseModel):
    id: str  # Changed from int
    label: str
    canister_type_id: int
    status: str
    created_at: datetime
```

### Validation Rules

**Label field:**
- Required (cannot be empty)
- Max length: 64 characters
- Can be non-unique (multiple canisters can have same label)
- Can be edited by users

**ID field:**
- Generated server-side only
- Immutable once created
- Format: `GC-[a-f0-9]{10}`
- Guaranteed unique by database constraint

## Frontend Changes

### URL Structure

**Before:**
- `/canister/1`
- `/canister/2/delete`

**After:**
- `/canister/GC-a3f8e52468`
- `/canister/GC-a3f8e52468/delete`

### Dashboard Template (`templates/dashboard.html`)

**Display changes:**
- Show both ID and label in canister cards
- Use label as primary display text
- Show ID in metadata/tooltip
- Links use UUID: `<a href="/canister/{{ canister.id }}">`

**Form changes:**
```html
<!-- Add Canister Form -->
<form action="/api/canisters" method="post">
    <!-- ID generated server-side, not in form -->

    <label>Label:</label>
    <input type="text"
           name="label"
           value="{{ suggested_label }}"
           placeholder="My Coleman canister"
           required
           maxlength="64">

    <label>Type:</label>
    <select name="canister_type_id">...</select>

    <button type="submit">Add Canister</button>
</form>
```

**Suggested label generation:**
- Generate UUID-based suggestion in `dashboard()` view
- Pre-fill label field with suggestion
- User can override with custom label

### Canister Detail Template (`templates/canister_detail.html`)

**Changes:**
- Page title shows label (friendly name)
- UUID displayed in metadata section
- Add edit functionality for label field
- Breadcrumbs show label, not UUID

**Layout example:**
```html
<h1>{{ canister.label }}</h1>
<p class="text-muted">ID: {{ canister.id }}</p>

<!-- Edit label functionality -->
<form action="/canister/{{ canister.id }}/update-label" method="post">
    <input type="text" name="label" value="{{ canister.label }}" maxlength="64" required>
    <button type="submit">Update Label</button>
</form>
```

### JavaScript Changes

**Chart.js:**
- API calls use string IDs in URLs
- No data type changes in chart rendering

**Form handling:**
- Remove ID generation from client-side
- Validation for label field (1-64 chars, required)

## Testing Updates

### Model Tests (`tests/test_models.py`)

**Update fixtures:**
```python
@pytest.fixture
def canister(db):
    canister_type = CanisterType.create(...)
    canister = Canister.create(
        id="GC-test001234",  # Use string ID
        label="Test Coleman",
        canister_type=canister_type
    )
    return canister
```

**New tests:**
- Verify UUID format matches `GC-[a-f0-9]{10}`
- Test label validation (empty, too long)
- Test ID uniqueness constraint

### API Tests

**Update assertions:**
```python
# Before
assert response.json()["id"] == 1

# After
assert response.json()["id"].startswith("GC-")
assert len(response.json()["id"]) == 13
```

### Integration Tests

- Test canister creation with auto-generated ID
- Test detail page access with UUID
- Test deletion with UUID
- Test label editing

## Error Handling

### Scenarios

1. **Invalid UUID format:**
   - FastAPI path validation handles malformed strings
   - Returns 422 Unprocessable Entity

2. **Canister not found:**
   - `Canister.get_by_id(canister_id)` raises `DoesNotExist`
   - Returns 404 Not Found

3. **Duplicate ID collision:**
   - Extremely unlikely with UUID+timestamp
   - Database raises `IntegrityError`
   - Return 500 Internal Server Error with retry logic

4. **Invalid label:**
   - Empty label: 422 with message "Label cannot be empty"
   - Too long: 422 with message "Label cannot exceed 64 characters"

### Edge Cases

- Label editing preserves ID (immutable)
- Multiple canisters can have same label (allowed)
- Foreign key cascade delete works identically with string IDs
- Sorting by ID: alphabetical ordering (acceptable)

## Migration Strategy

### Fresh Start Approach

**Steps:**
1. Drop existing tables
2. Recreate with new schema
3. Run seed data with UUID-based IDs
4. No migration script needed

**Rationale:**
- Development/staging environment
- Production database empty or acceptable to reset
- Simplest implementation
- No data preservation required

### Data Loss Implications

**What gets deleted:**
- All existing canisters
- All weighing records
- User must re-add canisters

**What persists:**
- Canister types (seed data)
- Application code and templates
- Docker volumes (but database recreated)

## Deployment Checklist

- [ ] Update `models.py` with new schema
- [ ] Add UUID generation function
- [ ] Update all route handlers (type hints and generation)
- [ ] Update request/response schemas
- [ ] Modify dashboard template (form and display)
- [ ] Modify detail template (UUID display, label editing)
- [ ] Add label update route and handler
- [ ] Update all URL references throughout templates
- [ ] Update JavaScript (if any ID-related code)
- [ ] Update all tests and fixtures
- [ ] Drop and recreate database
- [ ] Run seed data
- [ ] Test full workflow: create, view, edit label, delete
- [ ] Update CLAUDE.md documentation
- [ ] Deploy and verify in production

## Future Considerations

### Potential Enhancements

1. **Label search/filter:** Add search functionality by label
2. **Label validation:** Additional constraints (no special chars, etc.)
3. **UUID format validation:** Add regex validation in model
4. **Audit trail:** Track label changes over time
5. **Batch operations:** Support bulk label editing

### Not Included (YAGNI)

- Migration script for existing data (fresh start chosen)
- Label uniqueness constraint (not required)
- Custom UUID format selection (current format works well)
- QR code generation from UUID (no use case yet)

## Summary

This design replaces integer primary keys with UUID-based string identifiers while adding a separate user-editable label field. The approach maintains the current UUID format, uses application-level generation for clarity, and requires a fresh database start. All routes, templates, and tests will be updated to handle string IDs, with validation ensuring labels are 1-64 characters and required.
